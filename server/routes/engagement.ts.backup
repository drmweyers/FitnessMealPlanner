/**
 * Engagement API Routes - User Analytics and Interaction Tracking
 * 
 * Provides comprehensive user engagement tracking, analytics, and preference management.
 * Includes view tracking, ratings, interactions, and user preferences endpoints.
 */

import { Router, Request, Response, NextFunction } from 'express';
import { z } from 'zod';
import { getEngagementService } from '../services/EngagementService';
import { requireAuth } from '../middleware/auth';
import {
  rateRecipeSchema,
  updatePreferencesSchema,
  trackInteractionSchema,
  shareRecipeSchema, // from schema-social
  type RateRecipe,
  type UpdatePreferences,
  type TrackInteraction,
  type ShareRecipe
} from '../../shared/schema';

const router = Router();
const engagementService = getEngagementService();

// Rate limiting for analytics endpoints
const createRateLimiter = (windowMs: number, max: number) => {
  const windows = new Map<string, { count: number; resetTime: number }>();
  
  return (req: Request, res: Response, next: NextFunction) => {
    const key = `${req.ip}:${req.user?.id || 'anonymous'}`;
    const now = Date.now();
    const window = windows.get(key);
    
    if (!window || now > window.resetTime) {
      windows.set(key, { count: 1, resetTime: now + windowMs });
      return next();
    }
    
    if (window.count >= max) {
      return res.status(429).json({
        status: 'error',
        code: 'RATE_LIMIT_EXCEEDED',
        message: 'Too many requests. Please try again later.',
        retryAfter: Math.ceil((window.resetTime - now) / 1000)
      });
    }
    
    window.count++;
    next();
  };
};

// Rate limits
const analyticsRateLimit = createRateLimiter(60 * 1000, 100); // 100 requests per minute
const interactionRateLimit = createRateLimiter(60 * 1000, 200); // 200 interactions per minute
const preferencesRateLimit = createRateLimiter(60 * 1000, 5); // 5 preference updates per minute

// Validation middleware
const validateRequest = (schema: z.ZodSchema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      req.body = schema.parse(req.body);
      next();
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          status: 'error',
          code: 'VALIDATION_ERROR',
          message: 'Invalid request data',
          errors: error.errors.map(err => ({
            field: err.path.join('.'),
            message: err.message
          }))
        });
      }
      next(error);
    }
  };
};

// Query validation schemas
const viewTrackingSchema = z.object({
  recipeId: z.string().uuid(),
  viewDurationSeconds: z.number().int().min(0).max(3600).optional(),
  source: z.string().optional() // e.g., 'search', 'recommendation', 'trending'
});

const analyticsQuerySchema = z.object({
  recipeId: z.string().uuid().optional(),
  days: z.string().optional().transform(val => {
    if (!val) return 7;
    const parsed = parseInt(val);
    return isNaN(parsed) ? 7 : Math.min(Math.max(parsed, 1), 365);
  })
});

/**
 * View Tracking Endpoints
 */

// POST /api/analytics/recipe-view - Track recipe view
router.post(
  '/recipe-view',
  interactionRateLimit,
  validateRequest(viewTrackingSchema),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { recipeId, viewDurationSeconds, source } = req.body;
      const userId = req.user?.id;
      const sessionId = req.sessionID;
      const ipAddress = req.ip;
      const userAgent = req.get('User-Agent');

      await engagementService.trackRecipeView(
        recipeId,
        userId,
        sessionId,
        ipAddress,
        userAgent,
        viewDurationSeconds
      );

      // Also track as interaction if source is provided
      if (source) {
        await engagementService.trackInteraction(
          'recipe_view',
          userId,
          sessionId,
          'recipe',
          recipeId,
          { source, viewDurationSeconds }
        );
      }

      res.status(201).json({
        status: 'success',
        message: 'Recipe view tracked successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

// POST /api/analytics/interaction - Track user interaction
router.post(
  '/interaction',
  interactionRateLimit,
  validateRequest(trackInteractionSchema),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const { interactionType, targetType, targetId, metadata }: TrackInteraction = req.body;
      const userId = req.user?.id;
      const sessionId = req.sessionID;

      await engagementService.trackInteraction(
        interactionType,
        userId,
        sessionId,
        targetType,
        targetId,
        metadata
      );

      res.status(201).json({
        status: 'success',
        message: 'Interaction tracked successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * Recipe Rating Endpoints
 */

// POST /api/recipes/:id/rate - Rate a recipe
router.post(
  '/recipes/:id/rate',
  requireAuth,
  analyticsRateLimit,
  validateRequest(rateRecipeSchema),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userId = req.user!.id;
      const recipeId = req.params.id;
      const { rating, review }: RateRecipe = req.body;

      // Validate recipe ID format
      if (!z.string().uuid().safeParse(recipeId).success) {
        return res.status(400).json({
          status: 'error',
          code: 'INVALID_RECIPE_ID',
          message: 'Invalid recipe ID format'
        });
      }

      const result = await engagementService.rateRecipe(userId, recipeId, rating, review);

      if (!result) {
        return res.status(400).json({
          status: 'error',
          code: 'RATING_FAILED',
          message: 'Failed to rate recipe. Please try again.'
        });
      }

      res.status(201).json({
        status: 'success',
        data: {
          rating: result
        },
        message: 'Recipe rated successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

// GET /api/recipes/:id/ratings - Get recipe ratings
router.get(
  '/recipes/:id/ratings',
  analyticsRateLimit,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const recipeId = req.params.id;

      // Validate recipe ID format
      if (!z.string().uuid().safeParse(recipeId).success) {
        return res.status(400).json({
          status: 'error',
          code: 'INVALID_RECIPE_ID',
          message: 'Invalid recipe ID format'
        });
      }

      const analytics = await engagementService.getRecipeAnalytics(recipeId);

      res.json({
        status: 'success',
        data: {
          recipeId,
          averageRating: analytics.averageRating,
          totalRatings: analytics.totalRatings,
          engagementScore: analytics.engagementScore
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * Recipe Sharing Endpoints
 */

// POST /api/recipes/:id/share - Track recipe share
router.post(
  '/recipes/:id/share',
  interactionRateLimit,
  validateRequest(shareRecipeSchema),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const recipeId = req.params.id;
      const { shareMethod }: ShareRecipe = req.body;
      const userId = req.user?.id;

      // Validate recipe ID format
      if (!z.string().uuid().safeParse(recipeId).success) {
        return res.status(400).json({
          status: 'error',
          code: 'INVALID_RECIPE_ID',
          message: 'Invalid recipe ID format'
        });
      }

      await engagementService.trackRecipeShare(recipeId, shareMethod, userId);

      // Also track as interaction
      await engagementService.trackInteraction(
        'recipe_share',
        userId,
        req.sessionID,
        'recipe',
        recipeId,
        { shareMethod }
      );

      res.status(201).json({
        status: 'success',
        message: 'Recipe share tracked successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * User Analytics Endpoints
 */

// GET /api/analytics/user-activity - Get user activity summary
router.get(
  '/user-activity',
  requireAuth,
  analyticsRateLimit,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userId = req.user!.id;
      const activity = await engagementService.getUserActivity(userId);

      res.json({
        status: 'success',
        data: {
          activity
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

// GET /api/analytics/recipe/:id - Get recipe analytics
router.get(
  '/recipe/:id',
  analyticsRateLimit,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const recipeId = req.params.id;

      // Validate recipe ID format
      if (!z.string().uuid().safeParse(recipeId).success) {
        return res.status(400).json({
          status: 'error',
          code: 'INVALID_RECIPE_ID',
          message: 'Invalid recipe ID format'
        });
      }

      const analytics = await engagementService.getRecipeAnalytics(recipeId);

      res.json({
        status: 'success',
        data: {
          recipeId,
          analytics
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

// GET /api/analytics/interactions - Get interaction analytics
router.get(
  '/interactions',
  analyticsRateLimit,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const queryValidation = analyticsQuerySchema.safeParse(req.query);
      if (!queryValidation.success) {
        return res.status(400).json({
          status: 'error',
          code: 'INVALID_QUERY_PARAMS',
          message: 'Invalid query parameters'
        });
      }

      const { days } = queryValidation.data;
      const interactions = await engagementService.getInteractionAnalytics(days);

      res.json({
        status: 'success',
        data: {
          timeframe: `${days} days`,
          interactions
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * User Preferences Endpoints
 */

// GET /api/user/preferences - Get user preferences
router.get(
  '/user/preferences',
  requireAuth,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userId = req.user!.id;
      const preferences = await engagementService.getUserPreferences(userId);

      res.json({
        status: 'success',
        data: {
          preferences: preferences || {
            dietaryRestrictions: [],
            preferredIngredients: [],
            dislikedIngredients: [],
            allergies: [],
            preferredMealTypes: [],
            maxPrepTime: null,
            caloriePreference: null,
            spiceLevel: null,
            cuisinePreferences: []
          }
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

// PUT /api/user/preferences - Update user preferences
router.put(
  '/user/preferences',
  requireAuth,
  preferencesRateLimit,
  validateRequest(updatePreferencesSchema),
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userId = req.user!.id;
      const preferences: UpdatePreferences = req.body;

      const updatedPreferences = await engagementService.updateUserPreferences(userId, preferences);

      res.json({
        status: 'success',
        data: {
          preferences: updatedPreferences
        },
        message: 'Preferences updated successfully'
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * Trending and Popular Endpoints
 */

// GET /api/analytics/trending - Get trending recipes
router.get(
  '/trending',
  analyticsRateLimit,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const limitQuery = req.query.limit as string;
      const limit = limitQuery ? Math.min(parseInt(limitQuery), 50) : 20;

      if (isNaN(limit) || limit < 1) {
        return res.status(400).json({
          status: 'error',
          code: 'INVALID_LIMIT',
          message: 'Limit must be a positive number'
        });
      }

      const trending = await engagementService.getTrendingRecipes(limit);

      res.json({
        status: 'success',
        data: {
          trending,
          count: trending.length
        }
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * Feedback and Recommendation Endpoints
 */

// POST /api/user/recommendation-feedback - Provide feedback on recommendations
router.post(
  '/user/recommendation-feedback',
  requireAuth,
  interactionRateLimit,
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const userId = req.user!.id;
      const { recommendationId, feedback, reason } = req.body;

      // Validate input
      const feedbackSchema = z.object({
        recommendationId: z.string(),
        feedback: z.enum(['liked', 'disliked', 'not_interested', 'saved']),
        reason: z.string().optional()
      });

      const validatedData = feedbackSchema.parse(req.body);

      // Track as interaction
      await engagementService.trackInteraction(
        'recommendation_feedback',
        userId,
        req.sessionID,
        'recommendation',
        validatedData.recommendationId,
        {
          feedback: validatedData.feedback,
          reason: validatedData.reason
        }
      );

      res.status(201).json({
        status: 'success',
        message: 'Feedback recorded successfully'
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({
          status: 'error',
          code: 'VALIDATION_ERROR',
          message: 'Invalid feedback data',
          errors: error.errors
        });
      }
      next(error);
    }
  }
);

/**
 * Health Check Endpoint
 */
router.get(
  '/health',
  async (req: Request, res: Response, next: NextFunction) => {
    try {
      const health = await engagementService.healthCheck();
      
      const statusCode = health.status === 'healthy' ? 200 : 503;
      
      res.status(statusCode).json({
        status: health.status,
        service: 'EngagementService',
        message: health.message,
        timestamp: new Date().toISOString()
      });
    } catch (error) {
      next(error);
    }
  }
);

/**
 * Middleware for handling user agent parsing
 */
router.use((req: Request, res: Response, next: NextFunction) => {
  // Extract additional context from user agent if needed
  const userAgent = req.get('User-Agent') || '';
  
  // Simple device detection
  req.deviceInfo = {
    isMobile: /Mobile|Android|iPhone|iPad/.test(userAgent),
    isBot: /bot|crawler|spider/i.test(userAgent),
    browser: userAgent.split(' ')[0] || 'Unknown'
  };
  
  next();
});

/**
 * Error handling middleware
 */
router.use((error: any, req: Request, res: Response, next: NextFunction) => {
  console.error('Engagement API Error:', error);

  // Handle specific error types
  if (error.name === 'ValidationError') {
    return res.status(400).json({
      status: 'error',
      code: 'VALIDATION_ERROR',
      message: error.message
    });
  }

  if (error.code === '23503') { // PostgreSQL foreign key violation
    return res.status(400).json({
      status: 'error',
      code: 'INVALID_REFERENCE',
      message: 'Referenced recipe or user does not exist'
    });
  }

  if (error.code === '23505') { // PostgreSQL unique violation
    return res.status(409).json({
      status: 'error',
      code: 'DUPLICATE_ENTRY',
      message: 'Duplicate entry detected'
    });
  }

  // Default error response
  res.status(500).json({
    status: 'error',
    code: 'INTERNAL_SERVER_ERROR',
    message: 'An unexpected error occurred'
  });
});

// Extend Express Request interface for device info
declare global {
  namespace Express {
    interface Request {
      deviceInfo?: {
        isMobile: boolean;
        isBot: boolean;
        browser: string;
      };
    }
  }
}

export { router as engagementRouter };