/**
 * Usage Tracking Service
 *
 * Tracks detailed usage events for analytics and reporting:
 * - Meal plan generation events
 * - Recipe creation events
 * - Customer invitation events
 * - PDF export events
 *
 * Stores data in usage_tracking table for:
 * - Usage analytics dashboard
 * - Billing verification
 * - Abuse detection
 * - Feature usage insights
 */

import { db } from '../db';
import { usageTracking, users } from '@shared/schema';

export type UsageAction =
  | 'meal_plan_generated'
  | 'meal_plan_assigned'
  | 'recipe_created'
  | 'recipe_approved'
  | 'customer_invited'
  | 'pdf_exported'
  | 'progress_updated'
  | 'usage_limit_warning'
  | 'usage_limit_exceeded';

interface TrackUsageParams {
  userId: string;
  action: UsageAction;
  resourceId?: string;
  metadata?: Record<string, any>;
}

/**
 * Track a usage event
 */
export async function trackUsage({
  userId,
  action,
  resourceId,
  metadata = {},
}: TrackUsageParams): Promise<void> {
  try {
    await db.insert(usageTracking).values({
      userId,
      action,
      resourceId,
      metadata,
      createdAt: new Date(),
    });
  } catch (error) {
    // Log error but don't throw - tracking failures shouldn't break functionality
    console.error('Usage tracking error:', error);
  }
}

/**
 * Get usage summary for a user
 */
export async function getUserUsageSummary(userId: string, days: number = 30) {
  try {
    const since = new Date();
    since.setDate(since.getDate() - days);

    const events = await db
      .select()
      .from(usageTracking)
      .where(eq(usageTracking.userId, userId))
      .where(gte(usageTracking.createdAt, since))
      .orderBy(desc(usageTracking.createdAt));

    // Aggregate by action type
    const summary = events.reduce((acc, event) => {
      if (!acc[event.action]) {
        acc[event.action] = 0;
      }
      acc[event.action]++;
      return acc;
    }, {} as Record<string, number>);

    return {
      totalEvents: events.length,
      period: `${days} days`,
      summary,
      recentEvents: events.slice(0, 10), // Last 10 events
    };
  } catch (error) {
    console.error('Error getting usage summary:', error);
    return null;
  }
}

/**
 * Get usage analytics for admin dashboard
 */
export async function getUsageAnalytics(startDate: Date, endDate: Date) {
  try {
    const events = await db
      .select()
      .from(usageTracking)
      .where(gte(usageTracking.createdAt, startDate))
      .where(lte(usageTracking.createdAt, endDate));

    // Group by action
    const byAction = events.reduce((acc, event) => {
      if (!acc[event.action]) {
        acc[event.action] = [];
      }
      acc[event.action].push(event);
      return acc;
    }, {} as Record<string, any[]>);

    // Group by user
    const byUser = events.reduce((acc, event) => {
      if (!acc[event.userId]) {
        acc[event.userId] = [];
      }
      acc[event.userId].push(event);
      return acc;
    }, {} as Record<string, any[]>);

    // Calculate top users
    const topUsers = Object.entries(byUser)
      .map(([userId, userEvents]) => ({
        userId,
        eventCount: userEvents.length,
      }))
      .sort((a, b) => b.eventCount - a.eventCount)
      .slice(0, 10);

    return {
      totalEvents: events.length,
      period: {
        start: startDate,
        end: endDate,
      },
      byAction: Object.entries(byAction).map(([action, actionEvents]) => ({
        action,
        count: actionEvents.length,
      })),
      topUsers,
      dailyAverage: events.length / Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)),
    };
  } catch (error) {
    console.error('Error getting usage analytics:', error);
    return null;
  }
}

/**
 * Track meal plan generation with detailed metadata
 */
export async function trackMealPlanGeneration(
  userId: string,
  mealPlanId: string,
  metadata: {
    customerId?: string;
    planName?: string;
    daysCount?: number;
    recipesCount?: number;
    generationMethod?: 'ai' | 'manual';
  }
): Promise<void> {
  await trackUsage({
    userId,
    action: 'meal_plan_generated',
    resourceId: mealPlanId,
    metadata,
  });
}

/**
 * Track when user approaches usage limit (80% threshold)
 */
export async function trackUsageLimitWarning(
  userId: string,
  currentUsage: number,
  limit: number
): Promise<void> {
  await trackUsage({
    userId,
    action: 'usage_limit_warning',
    metadata: {
      currentUsage,
      limit,
      percentage: Math.round((currentUsage / limit) * 100),
    },
  });
}

/**
 * Track when user exceeds usage limit
 */
export async function trackUsageLimitExceeded(
  userId: string,
  currentUsage: number,
  limit: number
): Promise<void> {
  await trackUsage({
    userId,
    action: 'usage_limit_exceeded',
    metadata: {
      currentUsage,
      limit,
      exceededBy: currentUsage - limit,
    },
  });
}

/**
 * Detect potential abuse (unusually high usage in short period)
 */
export async function detectAbusePattern(userId: string): Promise<boolean> {
  try {
    const last24Hours = new Date();
    last24Hours.setHours(last24Hours.getHours() - 24);

    const recentEvents = await db
      .select()
      .from(usageTracking)
      .where(eq(usageTracking.userId, userId))
      .where(eq(usageTracking.action, 'meal_plan_generated'))
      .where(gte(usageTracking.createdAt, last24Hours));

    // Flag if more than 50 meal plans generated in 24 hours
    const ABUSE_THRESHOLD = 50;
    if (recentEvents.length > ABUSE_THRESHOLD) {
      console.warn(`⚠️ Potential abuse detected: User ${userId} generated ${recentEvents.length} meal plans in 24 hours`);

      // Track abuse event
      await trackUsage({
        userId,
        action: 'usage_limit_exceeded',
        metadata: {
          abuseDetection: true,
          eventCount: recentEvents.length,
          period: '24 hours',
          threshold: ABUSE_THRESHOLD,
        },
      });

      return true;
    }

    return false;
  } catch (error) {
    console.error('Error detecting abuse pattern:', error);
    return false;
  }
}

// Helper imports (add these at the top of the file if not already imported)
import { eq, gte, lte, desc } from 'drizzle-orm';
